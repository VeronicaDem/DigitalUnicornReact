import React from 'react';
import Error from './Error';
import {BrowserRouter} from 'react-router-dom';
import {Route} from 'react-router-dom';
import {Redirect} from 'react-router-dom';
import axios from "axios";

import AppBlogs from './AppBlogs';
import BecomeAuthor from './BecomeAuthor';
import Header from './Header';
import './style.css';

let JSON = [
  {
      "article_title":"Асинхронное программирование в Phyton: краткий обзор",
      "post_text": "Когда говорят о выполнении программ, то под «асинхронным выполнением» понимают такую ситуацию, когда программа не ждёт завершения некоего процесса, а продолжает работу независимо от него. В качестве примера асинхронного программирования можно привести утилиту, которая, работая асинхронно, делает записи в лог-файл. Хотя такая утилита и может дать сбой (например, из-за нехватки свободного места на диске) , в большинстве случаев она будет работать правильно и ей можно будет пользоваться в различных программах. Они смогут её вызывать, передавая ей данные для записи, а после этого смогут продолжать заниматься своими делами.Применение асинхронных механизмов при написании некоей программы означает, что эта программа будет выполняться быстрее, чем без использования подобных механизмов. При этом то, что планируется запускать асинхронно, вроде утилиты для логирования, должно быть написано с учётом возникновения нештатных ситуаций. Например, утилита для логирования, если место на диске закончилось, может просто прекратить логирование, а не «обваливать» ошибкой основную программу.Выполнение асинхронного кода обычно подразумевает работу такого кода в отдельном потоке. Это — если речь идёт о системе с одноядерным процессором. В системах с многоядерными процессорами подобный код вполне может выполняться процессом, пользующимся отдельным ядром. Одноядерный процессор в некий момент времени может считывать и выполнять лишь одну инструкцию. Это напоминает чтение книг. Нельзя читать две книги одновременно.Если вы читаете книгу, а кто-то даёт вам ещё одну книгу, вы можете взять эту вторую книгу и приступить к её чтению. Но первую придётся отложить. По такому же принципу устроено и многопоточное выполнение кода. А если бы несколько ваших копий читало бы сразу несколько книг, то это было бы похоже на то, как работают многопроцессорные системы.",
      "img1" : "images/pyton.png",
      "img2" : null,
      "img3" : null,
      "likes" : 2,
      "dislikes":1,
      "login": "Логин автора поста",
      "when": "2019-11-18T21:20:15",
      "user_img":"images/human.png"
  },
  {
    "article_title":"Bсинхронное программирование в Phyton: краткий обзор",
    "post_text": "Когда говорят о выполнении программ, то под «асинхронным выполнением» понимают такую ситуацию, когда программа не ждёт завершения некоего процесса, а продолжает работу независимо от него. В качестве примера асинхронного программирования можно привести утилиту, которая, работая асинхронно, делает записи в лог-файл. Хотя такая утилита и может дать сбой (например, из-за нехватки свободного места на диске) , в большинстве случаев она будет работать правильно и ей можно будет пользоваться в различных программах. Они смогут её вызывать, передавая ей данные для записи, а после этого смогут продолжать заниматься своими делами.Применение асинхронных механизмов при написании некоей программы означает, что эта программа будет выполняться быстрее, чем без использования подобных механизмов. При этом то, что планируется запускать асинхронно, вроде утилиты для логирования, должно быть написано с учётом возникновения нештатных ситуаций. Например, утилита для логирования, если место на диске закончилось, может просто прекратить логирование, а не «обваливать» ошибкой основную программу.Выполнение асинхронного кода обычно подразумевает работу такого кода в отдельном потоке. Это — если речь идёт о системе с одноядерным процессором. В системах с многоядерными процессорами подобный код вполне может выполняться процессом, пользующимся отдельным ядром. Одноядерный процессор в некий момент времени может считывать и выполнять лишь одну инструкцию. Это напоминает чтение книг. Нельзя читать две книги одновременно.Если вы читаете книгу, а кто-то даёт вам ещё одну книгу, вы можете взять эту вторую книгу и приступить к её чтению. Но первую придётся отложить. По такому же принципу устроено и многопоточное выполнение кода. А если бы несколько ваших копий читало бы сразу несколько книг, то это было бы похоже на то, как работают многопроцессорные системы.",
    "img1" : "images/pyton.png",
    "img2" : null,
    "img3" : null,
    "likes" : 2,
    "dislikes":1,
    "login": "Логин автора поста",
    "when": "2019-11-17T21:20:15",
    "user_img":"images/human.png"
},
{
  "article_title":"Cсинхронное программирование в Phyton: краткий обзор",
  "post_text": "Когда говорят о выполнении программ, то под «асинхронным выполнением» понимают такую ситуацию, когда программа не ждёт завершения некоего процесса, а продолжает работу независимо от него. В качестве примера асинхронного программирования можно привести утилиту, которая, работая асинхронно, делает записи в лог-файл. Хотя такая утилита и может дать сбой (например, из-за нехватки свободного места на диске) , в большинстве случаев она будет работать правильно и ей можно будет пользоваться в различных программах. Они смогут её вызывать, передавая ей данные для записи, а после этого смогут продолжать заниматься своими делами.Применение асинхронных механизмов при написании некоей программы означает, что эта программа будет выполняться быстрее, чем без использования подобных механизмов. При этом то, что планируется запускать асинхронно, вроде утилиты для логирования, должно быть написано с учётом возникновения нештатных ситуаций. Например, утилита для логирования, если место на диске закончилось, может просто прекратить логирование, а не «обваливать» ошибкой основную программу.Выполнение асинхронного кода обычно подразумевает работу такого кода в отдельном потоке. Это — если речь идёт о системе с одноядерным процессором. В системах с многоядерными процессорами подобный код вполне может выполняться процессом, пользующимся отдельным ядром. Одноядерный процессор в некий момент времени может считывать и выполнять лишь одну инструкцию. Это напоминает чтение книг. Нельзя читать две книги одновременно.Если вы читаете книгу, а кто-то даёт вам ещё одну книгу, вы можете взять эту вторую книгу и приступить к её чтению. Но первую придётся отложить. По такому же принципу устроено и многопоточное выполнение кода. А если бы несколько ваших копий читало бы сразу несколько книг, то это было бы похоже на то, как работают многопроцессорные системы.",
  "img1" : "images/pyton.png",
  "img2" : null,
  "img3" : null,
  "likes" : 2,
  "dislikes":1,
  "login": "Логин автора поста",
  "when": "2019-11-17T21:20:15",
  "user_img":"images/human.png"
},
{
  "article_title":"Dсинхронное программирование в Phyton: краткий обзор",
  "post_text": "Когда говорят о выполнении программ, то под «асинхронным выполнением» понимают такую ситуацию, когда программа не ждёт завершения некоего процесса, а продолжает работу независимо от него. В качестве примера асинхронного программирования можно привести утилиту, которая, работая асинхронно, делает записи в лог-файл. Хотя такая утилита и может дать сбой (например, из-за нехватки свободного места на диске) , в большинстве случаев она будет работать правильно и ей можно будет пользоваться в различных программах. Они смогут её вызывать, передавая ей данные для записи, а после этого смогут продолжать заниматься своими делами.Применение асинхронных механизмов при написании некоей программы означает, что эта программа будет выполняться быстрее, чем без использования подобных механизмов. При этом то, что планируется запускать асинхронно, вроде утилиты для логирования, должно быть написано с учётом возникновения нештатных ситуаций. Например, утилита для логирования, если место на диске закончилось, может просто прекратить логирование, а не «обваливать» ошибкой основную программу.Выполнение асинхронного кода обычно подразумевает работу такого кода в отдельном потоке. Это — если речь идёт о системе с одноядерным процессором. В системах с многоядерными процессорами подобный код вполне может выполняться процессом, пользующимся отдельным ядром. Одноядерный процессор в некий момент времени может считывать и выполнять лишь одну инструкцию. Это напоминает чтение книг. Нельзя читать две книги одновременно.Если вы читаете книгу, а кто-то даёт вам ещё одну книгу, вы можете взять эту вторую книгу и приступить к её чтению. Но первую придётся отложить. По такому же принципу устроено и многопоточное выполнение кода. А если бы несколько ваших копий читало бы сразу несколько книг, то это было бы похоже на то, как работают многопроцессорные системы.",
  "img1" : "images/pyton.png",
  "img2" : null,
  "img3" : null,
  "likes" : 2,
  "dislikes":1,
  "login": "Логин автора поста",
  "when": "2019-11-17T21:20:15",
  "user_img":"images/human.png"
},
{
  "article_title":"Eсинхронное программирование в Phyton: краткий обзор",
  "post_text": "Когда говорят о выполнении программ, то под «асинхронным выполнением» понимают такую ситуацию, когда программа не ждёт завершения некоего процесса, а продолжает работу независимо от него. В качестве примера асинхронного программирования можно привести утилиту, которая, работая асинхронно, делает записи в лог-файл. Хотя такая утилита и может дать сбой (например, из-за нехватки свободного места на диске) , в большинстве случаев она будет работать правильно и ей можно будет пользоваться в различных программах. Они смогут её вызывать, передавая ей данные для записи, а после этого смогут продолжать заниматься своими делами.Применение асинхронных механизмов при написании некоей программы означает, что эта программа будет выполняться быстрее, чем без использования подобных механизмов. При этом то, что планируется запускать асинхронно, вроде утилиты для логирования, должно быть написано с учётом возникновения нештатных ситуаций. Например, утилита для логирования, если место на диске закончилось, может просто прекратить логирование, а не «обваливать» ошибкой основную программу.Выполнение асинхронного кода обычно подразумевает работу такого кода в отдельном потоке. Это — если речь идёт о системе с одноядерным процессором. В системах с многоядерными процессорами подобный код вполне может выполняться процессом, пользующимся отдельным ядром. Одноядерный процессор в некий момент времени может считывать и выполнять лишь одну инструкцию. Это напоминает чтение книг. Нельзя читать две книги одновременно.Если вы читаете книгу, а кто-то даёт вам ещё одну книгу, вы можете взять эту вторую книгу и приступить к её чтению. Но первую придётся отложить. По такому же принципу устроено и многопоточное выполнение кода. А если бы несколько ваших копий читало бы сразу несколько книг, то это было бы похоже на то, как работают многопроцессорные системы.",
  "img1" : "images/pyton.png",
  "img2" : null,
  "img3" : null,
  "likes" : 2,
  "dislikes":1,
  "login": "Логин автора поста",
  "when": "2019-11-17T21:20:15",
  "user_img":"images/human.png"
}
]
class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      "start": 0,
      "how_much" : 2,
      "blogs": [],
      "from_search":false,
      "what_search":"",
      "is_max":false
    }
    this.handleChoice = this.handleChoice.bind(this);
    this.changeBlogs = this.changeBlogs.bind(this);
    this.handleChoiceClick = this.handleChoiceClick.bind(this);
    this.handleError = this.handleError.bind(this);
    this.updateBlogs = this.updateBlogs.bind(this);
  }
  async changeBlogs(e, mode) {
    /*
      Узнаем количество постов MAX
    */
  
   let blogs = this.state.blogs;
   let MAX;
   axios.get("/articles/max_count")
             .then((result)=>{
              MAX = result.data[0]["COUNT(*)"];
             })
             .catch((error)=>{
               this.setState({
                  error:error.message
               })
               return;
             });
  
   let how_much = this.state.how_much;
   let start;
   let result;
   if(MAX - this.state.blogs.length < this.state.how_much) {
      how_much = MAX - this.state.blogs.length;
      
   }
   if(this.state.from_search || this.state.to_start) {
     blogs = [];
      
   }
   
   if(blogs.length == 0) {
   
   /*
    запрашиваем данные из базы:
    JSON     
   */
  
  start = 0;
  
    result = axios.get(`/articles?start=${start}&size=${how_much}`)
    .then((response)=> {
      blogs =  response.data;
    })
    .catch((error)=> {
      this.setState({
        error:error.message
      })
      return;
    })
    ;
    /* */
    
   
   
    
   }
  else {
    start = blogs.length;
   
    how_much++;
    result =  axios.get(`/articles?start=${start}&size=${how_much}`)
               .then((response)=>{
                blogs = response.data;
               })
               .catch((error)=> {
                 this.setState({
                   error:error.message
                 })
                 return;
               });
  }
  if(this.state.from_search) {
    console.log(blogs);
  }
    this.setState({
      "blogs": blogs,
      "start": start,
      "from_search":false,
      to_start:false,
      is_max : MAX == blogs.length
    });
  
  }
  handleChoiceClick(e) {
    this.handleChoice(null);
  }
  async handleChoice(search) {
    /* забираем из бд только те записи, в которых article_title=from_search*/
    let blogs = this.state.blogs;
    search = search || this.state.what_search;

   
    if(search == this.state.what_search) {
      console.log("=");
    }
    if(!this.state.from_search)
        blogs = [];
    
    
   
   let MAX;
   axios.get(`/articles/max_count?startsWith=${search}`)
        .then((response)=>{
          MAX = response.data[0]["COUNT(*)"];
        })
        .catch((error)=>{
          this.setState({
            error:error.message
          })
          return;
        })
   let how_much = this.state.how_much;
   let start;
   if(blogs.length == 0) {
      start = 0;
      
   }
   else {
    start = blogs.length;
    how_much++; 
    
   }
   axios.get(`/articles?start=${start}&startsWith=${search}&size=${how_much}`)
        .then((response)=>{
          blogs = response.data;
        })
        .catch((error)=>{
          this.setState({
            error:error.message
          })
          return;
        })
        ;
    this.setState({
         blogs,
         from_search:true,
         to_start:true,
         what_search: search,
         is_max : MAX == blogs.length
    })
    
  }
 async updateBlogs() {
    let start = 0;
    let size = this.state.blogs.length;
    let blogs;
    axios.get(`/articles?start=${start}&size=${this.state.how_much}`)
               .then((response)=>{
                blogs = response.data;
               })
               .catch((error)=> {
                 this.setState({
                   error:error.message
                 })
                 return;
               });
    this.setState({
                "blogs": blogs,
                "start": start,
                "from_search":false,
                to_start:false
              });
              
  }
  componentWillMount() {
    document.body.className="";
    if(this.state.blogs.length == 0) {
      
      this.changeBlogs();
      
    }
    
  }
  
  handleError(error) {
    this.setState({
      error
    })
  }

  render() { 
    let error = "";
    if(this.state.error) {
      error = (
        <Error error={this.state.error} />
      )
    }
    let component;
    if(this.props.component == "AppBlogs") {
      component = (<AppBlogs 
      blogs={this.state.blogs}
      changeBlogs={this.state.changeBlogs}
      from_search={this.state.from_search}
      is_max={this.state.is_max}
      handleChoiceClick={this.state.handleChoiceClick}
      to_start={this.state.to_start}
      updateBlogs={this.state.updateBlogs}
      handleError={this.handleError}
      error={this.state.error}
    />);
    
    }
    if(this.props.component == "BecomeAuthor") {
      component = (
        <BecomeAuthor login={this.props.login}/>
      )
     
    }
    
    return(
      
    <div className="App">
      
     <Header handleChoice = {this.handleChoice} login={this.props.login} 
                   password={this.props.password} 
                   email={this.props.email}
                   user_img={this.props.user_img}
                   first_name={this.props.first_name}
                   last_name={this.props.last_name}
                   handleError={this.state.handleError}/>
      
    
    {component}
    </div>
  
  )
  }
}

export default App;
